{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport React from \"react\";\nimport { useWatch } from \"./useWatch\";\nimport { useCollection } from \"./useCollection\";\nimport { useRealmApp } from \"../components/RealmApp\";\nimport { dataSourceName } from \"../realm.json\";\nimport { addValueAtIndex, replaceValueAtIndex, updateValueAtIndex, removeValueAtIndex, getTodoIndex } from \"../utils\";\nexport function useTodos() {\n  _s();\n\n  // Set up a list of todos in state\n  const realmApp = useRealmApp();\n  const [todos, setTodos] = React.useState([]);\n  const [loading, setLoading] = React.useState(true); // Get a client object for the todo task collection\n\n  const taskCollection = useCollection({\n    cluster: dataSourceName,\n    db: \"todo\",\n    collection: \"Task\"\n  }); // Fetch all todos on load and whenever our collection changes (e.g. if the current user changes)\n\n  React.useEffect(() => {\n    taskCollection.find({}).then(fetchedTodos => {\n      setTodos(fetchedTodos);\n      setLoading(false);\n    });\n  }, [taskCollection]); // Use a MongoDB change stream to reactively update state when operations succeed\n\n  useWatch(taskCollection, {\n    onInsert: change => {\n      setTodos(oldTodos => {\n        var _getTodoIndex;\n\n        if (loading) {\n          return oldTodos;\n        }\n\n        const idx = (_getTodoIndex = getTodoIndex(oldTodos, change.fullDocument)) !== null && _getTodoIndex !== void 0 ? _getTodoIndex : oldTodos.length;\n\n        if (idx === oldTodos.length) {\n          return addValueAtIndex(oldTodos, idx, change.fullDocument);\n        } else {\n          return oldTodos;\n        }\n      });\n    },\n    onUpdate: change => {\n      setTodos(oldTodos => {\n        if (loading) {\n          return oldTodos;\n        }\n\n        const idx = getTodoIndex(oldTodos, change.fullDocument);\n        return updateValueAtIndex(oldTodos, idx, () => {\n          return change.fullDocument;\n        });\n      });\n    },\n    onReplace: change => {\n      setTodos(oldTodos => {\n        if (loading) {\n          return oldTodos;\n        }\n\n        const idx = getTodoIndex(oldTodos, change.fullDocument);\n        return replaceValueAtIndex(oldTodos, idx, change.fullDocument);\n      });\n    },\n    onDelete: change => {\n      setTodos(oldTodos => {\n        if (loading) {\n          return oldTodos;\n        }\n\n        const idx = getTodoIndex(oldTodos, {\n          _id: change.documentKey._id\n        });\n\n        if (idx >= 0) {\n          return removeValueAtIndex(oldTodos, idx);\n        } else {\n          return oldTodos;\n        }\n      });\n    }\n  }); // Given a draft todo, format it and then insert it\n\n  const saveTodo = async draftTodo => {\n    if (draftTodo.summary) {\n      draftTodo._partition = realmApp.currentUser.id;\n\n      try {\n        await taskCollection.insertOne(draftTodo);\n      } catch (err) {\n        if (err.error.match(/^Duplicate key error/)) {\n          console.warn(`The following error means that we tried to insert a todo multiple times (i.e. an existing todo has the same _id). In this app we just catch the error and move on. In your app, you might want to debounce the save input or implement an additional loading state to avoid sending the request in the first place.`);\n        }\n\n        console.error(err);\n      }\n    }\n  }; // Toggle whether or not a given todo is complete\n\n\n  const toggleTodo = async todo => {\n    await taskCollection.updateOne({\n      _id: todo._id\n    }, {\n      $set: {\n        isComplete: !todo.isComplete\n      }\n    });\n  }; // Delete a given todo\n\n\n  const deleteTodo = async todo => {\n    await taskCollection.deleteOne({\n      _id: todo._id\n    });\n  };\n\n  return {\n    loading,\n    todos,\n    saveTodo,\n    toggleTodo,\n    deleteTodo\n  };\n}\n\n_s(useTodos, \"xPDXlYz3qXCTE6niIm1yyuMNG20=\", false, function () {\n  return [useRealmApp, useCollection, useWatch];\n});","map":{"version":3,"sources":["C:/Users/Donovan/aegisproject/src/hooks/useTodos_mql.js"],"names":["React","useWatch","useCollection","useRealmApp","dataSourceName","addValueAtIndex","replaceValueAtIndex","updateValueAtIndex","removeValueAtIndex","getTodoIndex","useTodos","realmApp","todos","setTodos","useState","loading","setLoading","taskCollection","cluster","db","collection","useEffect","find","then","fetchedTodos","onInsert","change","oldTodos","idx","fullDocument","length","onUpdate","onReplace","onDelete","_id","documentKey","saveTodo","draftTodo","summary","_partition","currentUser","id","insertOne","err","error","match","console","warn","toggleTodo","todo","updateOne","$set","isComplete","deleteTodo","deleteOne"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport { useWatch } from \"./useWatch\";\nimport { useCollection } from \"./useCollection\";\nimport { useRealmApp } from \"../components/RealmApp\";\nimport { dataSourceName } from \"../realm.json\";\nimport {\n  addValueAtIndex,\n  replaceValueAtIndex,\n  updateValueAtIndex,\n  removeValueAtIndex,\n  getTodoIndex,\n} from \"../utils\";\n\nexport function useTodos() {\n  // Set up a list of todos in state\n  const realmApp = useRealmApp();\n  const [todos, setTodos] = React.useState([]);\n  const [loading, setLoading] = React.useState(true);\n\n  // Get a client object for the todo task collection\n  const taskCollection = useCollection({\n    cluster: dataSourceName,\n    db: \"todo\",\n    collection: \"Task\",\n  });\n\n  // Fetch all todos on load and whenever our collection changes (e.g. if the current user changes)\n  React.useEffect(() => {\n    taskCollection.find({}).then((fetchedTodos) => {\n      setTodos(fetchedTodos);\n      setLoading(false);\n    });\n  }, [taskCollection]);\n\n  // Use a MongoDB change stream to reactively update state when operations succeed\n  useWatch(taskCollection, {\n    onInsert: (change) => {\n      setTodos((oldTodos) => {\n        if (loading) {\n          return oldTodos;\n        }\n        const idx =\n          getTodoIndex(oldTodos, change.fullDocument) ?? oldTodos.length;\n        if (idx === oldTodos.length) {\n          return addValueAtIndex(oldTodos, idx, change.fullDocument);\n        } else {\n          return oldTodos;\n        }\n      });\n    },\n    onUpdate: (change) => {\n      setTodos((oldTodos) => {\n        if (loading) {\n          return oldTodos;\n        }\n        const idx = getTodoIndex(oldTodos, change.fullDocument);\n        return updateValueAtIndex(oldTodos, idx, () => {\n          return change.fullDocument;\n        });\n      });\n    },\n    onReplace: (change) => {\n      setTodos((oldTodos) => {\n        if (loading) {\n          return oldTodos;\n        }\n        const idx = getTodoIndex(oldTodos, change.fullDocument);\n        return replaceValueAtIndex(oldTodos, idx, change.fullDocument);\n      });\n    },\n    onDelete: (change) => {\n      setTodos((oldTodos) => {\n        if (loading) {\n          return oldTodos;\n        }\n        const idx = getTodoIndex(oldTodos, { _id: change.documentKey._id });\n        if (idx >= 0) {\n          return removeValueAtIndex(oldTodos, idx);\n        } else {\n          return oldTodos;\n        }\n      });\n    },\n  });\n\n  // Given a draft todo, format it and then insert it\n  const saveTodo = async (draftTodo) => {\n    if (draftTodo.summary) {\n      draftTodo._partition = realmApp.currentUser.id;\n      try {\n        await taskCollection.insertOne(draftTodo);\n      } catch (err) {\n        if (err.error.match(/^Duplicate key error/)) {\n          console.warn(\n            `The following error means that we tried to insert a todo multiple times (i.e. an existing todo has the same _id). In this app we just catch the error and move on. In your app, you might want to debounce the save input or implement an additional loading state to avoid sending the request in the first place.`\n          );\n        }\n        console.error(err);\n      }\n    }\n  };\n\n  // Toggle whether or not a given todo is complete\n  const toggleTodo = async (todo) => {\n    await taskCollection.updateOne(\n      { _id: todo._id },\n      { $set: { isComplete: !todo.isComplete } }\n    );\n  };\n\n  // Delete a given todo\n  const deleteTodo = async (todo) => {\n    await taskCollection.deleteOne({ _id: todo._id });\n  };\n\n  return {\n    loading,\n    todos,\n    saveTodo,\n    toggleTodo,\n    deleteTodo,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}