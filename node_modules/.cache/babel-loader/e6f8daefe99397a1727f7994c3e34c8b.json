{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport React from \"react\"; // By default we won't do anything for a change event unless the caller passed in a change handler\n// for the change event type.\n\nconst noop = () => {};\n\nconst defaultChangeHandlers = {\n  onInsert: noop,\n  onUpdate: noop,\n  onReplace: noop,\n  onDelete: noop\n};\n/**\n * Opens/manages a change stream and calls provided change handlers for a given MongoDB collection.\n * @param {Realm.Services.MongoDB.MongoDBCollection<T>} collection - A MongoDB collection client object.\n * @param {Object} changeHandlers - A set of callback functions to call in response to changes.\n * @param {(change: Realm.Services.MongoDB.InsertEvent<T>) => void} [changeHandlers.onInsert] - A change handler callback that receives an Insert event.\n * @param {(change: Realm.Services.MongoDB.UpdateEvent<T>) => void} [changeHandlers.onUpdate] - A change handler callback that receives an Update event.\n * @param {(change: Realm.Services.MongoDB.ReplaceEvent<T>) => void} [changeHandlers.onReplace] - A change handler callback that receives a Replace event.\n * @param {(change: Realm.Services.MongoDB.DeleteEvent<T>) => void} [changeHandlers.onDelete] - A change handler callback that receives a Delete event.\n */\n\nexport function useWatch(collection, changeHandlers) {\n  _s();\n\n  const filter = React.useMemo(() => ({}), []);\n  const handlers = { ...defaultChangeHandlers,\n    ...changeHandlers\n  }; // We copy the handlers into a ref so that we can always call the latest version of each handler\n  // without causing a re-render when the callbacks change. This can prevent infinite render loops\n  // that would otherwise happen if the caller doesn't memoize their change handler functions.\n\n  const handlersRef = React.useRef(handlers);\n  React.useEffect(() => {\n    handlersRef.current = {\n      onInsert: handlers.onInsert,\n      onUpdate: handlers.onUpdate,\n      onReplace: handlers.onReplace,\n      onDelete: handlers.onDelete\n    };\n  }, [handlers.onInsert, handlers.onUpdate, handlers.onReplace, handlers.onDelete]); // Set up a MongoDB change stream that calls the provided change handler callbacks.\n\n  React.useEffect(() => {\n    const watchTodos = async () => {\n      for await (const change of collection.watch({\n        filter\n      })) {\n        switch (change.operationType) {\n          case \"insert\":\n            {\n              handlersRef.current.onInsert(change);\n              break;\n            }\n\n          case \"update\":\n            {\n              handlersRef.current.onUpdate(change);\n              break;\n            }\n\n          case \"replace\":\n            {\n              handlersRef.current.onReplace(change);\n              break;\n            }\n\n          case \"delete\":\n            {\n              handlersRef.current.onDelete(change);\n              break;\n            }\n\n          default:\n            {\n              // change.operationType will always be one of the specified cases, so we should never hit this default\n              throw new Error(`Invalid change operation type: ${change.operationType}`);\n            }\n        }\n      }\n    };\n\n    watchTodos();\n  }, [collection, filter]);\n}\n\n_s(useWatch, \"lWv0FHOCtMCtTznGRdfg71sVPxg=\");","map":{"version":3,"sources":["C:/Users/Donovan/aegisproject/src/hooks/useWatch.js"],"names":["React","noop","defaultChangeHandlers","onInsert","onUpdate","onReplace","onDelete","useWatch","collection","changeHandlers","filter","useMemo","handlers","handlersRef","useRef","useEffect","current","watchTodos","change","watch","operationType","Error"],"mappings":";;AAAA,OAAOA,KAAP,MAAkB,OAAlB,C,CAEA;AACA;;AACA,MAAMC,IAAI,GAAG,MAAM,CAAE,CAArB;;AACA,MAAMC,qBAAqB,GAAG;AAC5BC,EAAAA,QAAQ,EAAEF,IADkB;AAE5BG,EAAAA,QAAQ,EAAEH,IAFkB;AAG5BI,EAAAA,SAAS,EAAEJ,IAHiB;AAI5BK,EAAAA,QAAQ,EAAEL;AAJkB,CAA9B;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASM,QAAT,CAAkBC,UAAlB,EAA8BC,cAA9B,EAA8C;AAAA;;AACnD,QAAMC,MAAM,GAAGV,KAAK,CAACW,OAAN,CAAc,OAAO,EAAP,CAAd,EAA0B,EAA1B,CAAf;AACA,QAAMC,QAAQ,GAAG,EAAE,GAAGV,qBAAL;AAA4B,OAAGO;AAA/B,GAAjB,CAFmD,CAGnD;AACA;AACA;;AACA,QAAMI,WAAW,GAAGb,KAAK,CAACc,MAAN,CAAaF,QAAb,CAApB;AACAZ,EAAAA,KAAK,CAACe,SAAN,CAAgB,MAAM;AACpBF,IAAAA,WAAW,CAACG,OAAZ,GAAsB;AACpBb,MAAAA,QAAQ,EAAES,QAAQ,CAACT,QADC;AAEpBC,MAAAA,QAAQ,EAAEQ,QAAQ,CAACR,QAFC;AAGpBC,MAAAA,SAAS,EAAEO,QAAQ,CAACP,SAHA;AAIpBC,MAAAA,QAAQ,EAAEM,QAAQ,CAACN;AAJC,KAAtB;AAMD,GAPD,EAOG,CACDM,QAAQ,CAACT,QADR,EAEDS,QAAQ,CAACR,QAFR,EAGDQ,QAAQ,CAACP,SAHR,EAIDO,QAAQ,CAACN,QAJR,CAPH,EAPmD,CAoBnD;;AACAN,EAAAA,KAAK,CAACe,SAAN,CAAgB,MAAM;AACpB,UAAME,UAAU,GAAG,YAAY;AAC7B,iBAAW,MAAMC,MAAjB,IAA2BV,UAAU,CAACW,KAAX,CAAiB;AAAET,QAAAA;AAAF,OAAjB,CAA3B,EAAyD;AACvD,gBAAQQ,MAAM,CAACE,aAAf;AACE,eAAK,QAAL;AAAe;AACbP,cAAAA,WAAW,CAACG,OAAZ,CAAoBb,QAApB,CAA6Be,MAA7B;AACA;AACD;;AACD,eAAK,QAAL;AAAe;AACbL,cAAAA,WAAW,CAACG,OAAZ,CAAoBZ,QAApB,CAA6Bc,MAA7B;AACA;AACD;;AACD,eAAK,SAAL;AAAgB;AACdL,cAAAA,WAAW,CAACG,OAAZ,CAAoBX,SAApB,CAA8Ba,MAA9B;AACA;AACD;;AACD,eAAK,QAAL;AAAe;AACbL,cAAAA,WAAW,CAACG,OAAZ,CAAoBV,QAApB,CAA6BY,MAA7B;AACA;AACD;;AACD;AAAS;AACP;AACA,oBAAM,IAAIG,KAAJ,CACH,kCAAiCH,MAAM,CAACE,aAAc,EADnD,CAAN;AAGD;AAtBH;AAwBD;AACF,KA3BD;;AA4BAH,IAAAA,UAAU;AACX,GA9BD,EA8BG,CAACT,UAAD,EAAaE,MAAb,CA9BH;AA+BD;;GApDeH,Q","sourcesContent":["import React from \"react\";\n\n// By default we won't do anything for a change event unless the caller passed in a change handler\n// for the change event type.\nconst noop = () => {};\nconst defaultChangeHandlers = {\n  onInsert: noop,\n  onUpdate: noop,\n  onReplace: noop,\n  onDelete: noop,\n};\n\n/**\n * Opens/manages a change stream and calls provided change handlers for a given MongoDB collection.\n * @param {Realm.Services.MongoDB.MongoDBCollection<T>} collection - A MongoDB collection client object.\n * @param {Object} changeHandlers - A set of callback functions to call in response to changes.\n * @param {(change: Realm.Services.MongoDB.InsertEvent<T>) => void} [changeHandlers.onInsert] - A change handler callback that receives an Insert event.\n * @param {(change: Realm.Services.MongoDB.UpdateEvent<T>) => void} [changeHandlers.onUpdate] - A change handler callback that receives an Update event.\n * @param {(change: Realm.Services.MongoDB.ReplaceEvent<T>) => void} [changeHandlers.onReplace] - A change handler callback that receives a Replace event.\n * @param {(change: Realm.Services.MongoDB.DeleteEvent<T>) => void} [changeHandlers.onDelete] - A change handler callback that receives a Delete event.\n */\nexport function useWatch(collection, changeHandlers) {\n  const filter = React.useMemo(() => ({}), []);\n  const handlers = { ...defaultChangeHandlers, ...changeHandlers };\n  // We copy the handlers into a ref so that we can always call the latest version of each handler\n  // without causing a re-render when the callbacks change. This can prevent infinite render loops\n  // that would otherwise happen if the caller doesn't memoize their change handler functions.\n  const handlersRef = React.useRef(handlers);\n  React.useEffect(() => {\n    handlersRef.current = {\n      onInsert: handlers.onInsert,\n      onUpdate: handlers.onUpdate,\n      onReplace: handlers.onReplace,\n      onDelete: handlers.onDelete,\n    };\n  }, [\n    handlers.onInsert,\n    handlers.onUpdate,\n    handlers.onReplace,\n    handlers.onDelete,\n  ]);\n  // Set up a MongoDB change stream that calls the provided change handler callbacks.\n  React.useEffect(() => {\n    const watchTodos = async () => {\n      for await (const change of collection.watch({ filter })) {\n        switch (change.operationType) {\n          case \"insert\": {\n            handlersRef.current.onInsert(change);\n            break;\n          }\n          case \"update\": {\n            handlersRef.current.onUpdate(change);\n            break;\n          }\n          case \"replace\": {\n            handlersRef.current.onReplace(change);\n            break;\n          }\n          case \"delete\": {\n            handlersRef.current.onDelete(change);\n            break;\n          }\n          default: {\n            // change.operationType will always be one of the specified cases, so we should never hit this default\n            throw new Error(\n              `Invalid change operation type: ${change.operationType}`\n            );\n          }\n        }\n      }\n    };\n    watchTodos();\n  }, [collection, filter]);\n}\n"]},"metadata":{},"sourceType":"module"}